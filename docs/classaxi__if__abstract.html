<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>AXI muckbucket: axi_if_abstract Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AXI muckbucket
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classaxi__if__abstract-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">axi_if_abstract Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>abstract base class for polymorphic interface class (axi_if_concrete) for AXI UVM environment  
 <a href="classaxi__if__abstract.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for axi_if_abstract:</div>
<div class="dyncontent">
<div class="center"><img src="classaxi__if__abstract__inherit__graph.png" border="0" usemap="#axi__if__abstract_inherit__map" alt="Inheritance graph"/></div>
<map name="axi__if__abstract_inherit__map" id="axi__if__abstract_inherit__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for axi_if_abstract:</div>
<div class="dyncontent">
<div class="center"><img src="classaxi__if__abstract__coll__graph.png" border="0" usemap="#axi__if__abstract_coll__map" alt="Collaboration graph"/></div>
<map name="axi__if__abstract_coll__map" id="axi__if__abstract_coll__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9ec99974902d3dee6694b6731631e326"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#a9ec99974902d3dee6694b6731631e326">uvm_object_utils</a> (<a class="el" href="classaxi__if__abstract.html">axi_if_abstract</a>) new(string name</td></tr>
<tr class="separator:a9ec99974902d3dee6694b6731631e326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834de2d058eec05c4c890435fae83a5b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#a834de2d058eec05c4c890435fae83a5b">get_data_bus_width</a> ()</td></tr>
<tr class="memdesc:a834de2d058eec05c4c890435fae83a5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns data bus width  <a href="#a834de2d058eec05c4c890435fae83a5b">More...</a><br /></td></tr>
<tr class="separator:a834de2d058eec05c4c890435fae83a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c572b96776c9da41b06e86331ed0e6"><td class="memItemLeft" align="right" valign="top">virtual task&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#a79c572b96776c9da41b06e86331ed0e6">wait_for_clks</a> (int cnt=1)</td></tr>
<tr class="memdesc:a79c572b96776c9da41b06e86331ed0e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">used for waiting  <a href="#a79c572b96776c9da41b06e86331ed0e6">More...</a><br /></td></tr>
<tr class="separator:a79c572b96776c9da41b06e86331ed0e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c1b5d16686699c5916f43aa20ae278"><td class="memItemLeft" align="right" valign="top">virtual task&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#ad3c1b5d16686699c5916f43aa20ae278">wait_for_not_in_reset</a> ()</td></tr>
<tr class="memdesc:ad3c1b5d16686699c5916f43aa20ae278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for reset to deassert.  <a href="#ad3c1b5d16686699c5916f43aa20ae278">More...</a><br /></td></tr>
<tr class="separator:ad3c1b5d16686699c5916f43aa20ae278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae136ae0143b1a3fccc030fbdb9dd32fa"><td class="memItemLeft" align="right" valign="top">virtual task&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#ae136ae0143b1a3fccc030fbdb9dd32fa">wait_for_awready_awvalid</a> ()</td></tr>
<tr class="memdesc:ae136ae0143b1a3fccc030fbdb9dd32fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for both awready awvalid to assert.  <a href="#ae136ae0143b1a3fccc030fbdb9dd32fa">More...</a><br /></td></tr>
<tr class="separator:ae136ae0143b1a3fccc030fbdb9dd32fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91fb21011e5b40e3d25aeea49284220"><td class="memItemLeft" align="right" valign="top">virtual task&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#ac91fb21011e5b40e3d25aeea49284220">wait_for_awvalid</a> ()</td></tr>
<tr class="memdesc:ac91fb21011e5b40e3d25aeea49284220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for awvalid to assert.  <a href="#ac91fb21011e5b40e3d25aeea49284220">More...</a><br /></td></tr>
<tr class="separator:ac91fb21011e5b40e3d25aeea49284220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8a696dbe605ca57a204f691e3b99db"><td class="memItemLeft" align="right" valign="top">virtual task&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#aee8a696dbe605ca57a204f691e3b99db">wait_for_wready</a> ()</td></tr>
<tr class="memdesc:aee8a696dbe605ca57a204f691e3b99db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for awready to assert.  <a href="#aee8a696dbe605ca57a204f691e3b99db">More...</a><br /></td></tr>
<tr class="separator:aee8a696dbe605ca57a204f691e3b99db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d26646215b46420b0cfd2ab10127d4"><td class="memItemLeft" align="right" valign="top">virtual task&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#a82d26646215b46420b0cfd2ab10127d4">wait_for_bvalid</a> ()</td></tr>
<tr class="memdesc:a82d26646215b46420b0cfd2ab10127d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for bvalid to assert.  <a href="#a82d26646215b46420b0cfd2ab10127d4">More...</a><br /></td></tr>
<tr class="separator:a82d26646215b46420b0cfd2ab10127d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e019c384309938d98fb93eb9d19ee35"><td class="memItemLeft" align="right" valign="top">virtual task&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#a9e019c384309938d98fb93eb9d19ee35">wait_for_write_address</a> (output <a class="el" href="axi__pkg_8sv.html#structaxi__seq__item__aw__vector__s">axi_seq_item_aw_vector_s</a> s)</td></tr>
<tr class="memdesc:a9e019c384309938d98fb93eb9d19ee35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a valid write address to be acknowledged and return it.  <a href="#a9e019c384309938d98fb93eb9d19ee35">More...</a><br /></td></tr>
<tr class="separator:a9e019c384309938d98fb93eb9d19ee35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a2ca6a8c9c35f84db03942796fc092"><td class="memItemLeft" align="right" valign="top">virtual task&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#ae1a2ca6a8c9c35f84db03942796fc092">wait_for_write_data</a> (output <a class="el" href="axi__pkg_8sv.html#structaxi__seq__item__w__vector__s">axi_seq_item_w_vector_s</a> s)</td></tr>
<tr class="memdesc:ae1a2ca6a8c9c35f84db03942796fc092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a valid write data to be acknowledged and return it.  <a href="#ae1a2ca6a8c9c35f84db03942796fc092">More...</a><br /></td></tr>
<tr class="separator:ae1a2ca6a8c9c35f84db03942796fc092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5030adaa9d120c151c041912c25bc538"><td class="memItemLeft" align="right" valign="top">virtual task&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#a5030adaa9d120c151c041912c25bc538">wait_for_write_response</a> (output <a class="el" href="axi__pkg_8sv.html#structaxi__seq__item__b__vector__s">axi_seq_item_b_vector_s</a> s)</td></tr>
<tr class="memdesc:a5030adaa9d120c151c041912c25bc538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a valid write response to be acknowledged and return it.  <a href="#a5030adaa9d120c151c041912c25bc538">More...</a><br /></td></tr>
<tr class="separator:a5030adaa9d120c151c041912c25bc538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac122b014826138edcbb74b601b625364"><td class="memItemLeft" align="right" valign="top">virtual task&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#ac122b014826138edcbb74b601b625364">wait_for_read_address</a> (output <a class="el" href="axi__pkg_8sv.html#structaxi__seq__item__ar__vector__s">axi_seq_item_ar_vector_s</a> s)</td></tr>
<tr class="memdesc:ac122b014826138edcbb74b601b625364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a valid read address to be acknowledged and return it.  <a href="#ac122b014826138edcbb74b601b625364">More...</a><br /></td></tr>
<tr class="separator:ac122b014826138edcbb74b601b625364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad72883433768852cedc9acbf5263e071"><td class="memItemLeft" align="right" valign="top">virtual task&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#ad72883433768852cedc9acbf5263e071">wait_for_read_data</a> (output <a class="el" href="axi__pkg_8sv.html#structaxi__seq__item__r__vector__s">axi_seq_item_r_vector_s</a> s)</td></tr>
<tr class="memdesc:ad72883433768852cedc9acbf5263e071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a valid read data to be acknowledged and return it.  <a href="#ad72883433768852cedc9acbf5263e071">More...</a><br /></td></tr>
<tr class="separator:ad72883433768852cedc9acbf5263e071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf98bd165754605b7878b05f63fe8b6"><td class="memItemLeft" align="right" valign="top">virtual bit&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#abbf98bd165754605b7878b05f63fe8b6">get_awready_awvalid</a> ()</td></tr>
<tr class="memdesc:abbf98bd165754605b7878b05f63fe8b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of awready and awvalid.  <a href="#abbf98bd165754605b7878b05f63fe8b6">More...</a><br /></td></tr>
<tr class="separator:abbf98bd165754605b7878b05f63fe8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ffe576057c4ab3cb114da13d10626f3"><td class="memItemLeft" align="right" valign="top">virtual bit&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#a9ffe576057c4ab3cb114da13d10626f3">get_awready</a> ()</td></tr>
<tr class="memdesc:a9ffe576057c4ab3cb114da13d10626f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of awready.  <a href="#a9ffe576057c4ab3cb114da13d10626f3">More...</a><br /></td></tr>
<tr class="separator:a9ffe576057c4ab3cb114da13d10626f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90f9b3a4524fa9a6fd7085292e2e109"><td class="memItemLeft" align="right" valign="top">virtual bit&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#aa90f9b3a4524fa9a6fd7085292e2e109">get_wready_wvalid</a> ()</td></tr>
<tr class="memdesc:aa90f9b3a4524fa9a6fd7085292e2e109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of wready and wvalid.  <a href="#aa90f9b3a4524fa9a6fd7085292e2e109">More...</a><br /></td></tr>
<tr class="separator:aa90f9b3a4524fa9a6fd7085292e2e109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5812097a1ebe2ea45d79b9453fccaa"><td class="memItemLeft" align="right" valign="top">virtual bit&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#a7b5812097a1ebe2ea45d79b9453fccaa">get_wvalid</a> ()</td></tr>
<tr class="memdesc:a7b5812097a1ebe2ea45d79b9453fccaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of wvalid.  <a href="#a7b5812097a1ebe2ea45d79b9453fccaa">More...</a><br /></td></tr>
<tr class="separator:a7b5812097a1ebe2ea45d79b9453fccaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab14f30e2f16ecda87111231fa0a1a332"><td class="memItemLeft" align="right" valign="top">virtual bit&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#ab14f30e2f16ecda87111231fa0a1a332">get_wready</a> ()</td></tr>
<tr class="memdesc:ab14f30e2f16ecda87111231fa0a1a332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of wready.  <a href="#ab14f30e2f16ecda87111231fa0a1a332">More...</a><br /></td></tr>
<tr class="separator:ab14f30e2f16ecda87111231fa0a1a332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4f687586493cda59b997ecb9b06755"><td class="memItemLeft" align="right" valign="top">virtual bit&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#afc4f687586493cda59b997ecb9b06755">get_bready_bvalid</a> ()</td></tr>
<tr class="memdesc:afc4f687586493cda59b997ecb9b06755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of bready and bvalid.  <a href="#afc4f687586493cda59b997ecb9b06755">More...</a><br /></td></tr>
<tr class="separator:afc4f687586493cda59b997ecb9b06755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e480323f9947438602bf6b5029783e1"><td class="memItemLeft" align="right" valign="top">virtual bit&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#a6e480323f9947438602bf6b5029783e1">get_bvalid</a> ()</td></tr>
<tr class="memdesc:a6e480323f9947438602bf6b5029783e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of bvalid.  <a href="#a6e480323f9947438602bf6b5029783e1">More...</a><br /></td></tr>
<tr class="separator:a6e480323f9947438602bf6b5029783e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a26bec3816fad1bb2155873214e9fc"><td class="memItemLeft" align="right" valign="top">virtual bit&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#ad1a26bec3816fad1bb2155873214e9fc">get_bready</a> ()</td></tr>
<tr class="memdesc:ad1a26bec3816fad1bb2155873214e9fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of bready.  <a href="#ad1a26bec3816fad1bb2155873214e9fc">More...</a><br /></td></tr>
<tr class="separator:ad1a26bec3816fad1bb2155873214e9fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c9bca94f0404a67cd00a2333a3fd10"><td class="memItemLeft" align="right" valign="top">virtual bit&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#a63c9bca94f0404a67cd00a2333a3fd10">get_arready_arvalid</a> ()</td></tr>
<tr class="memdesc:a63c9bca94f0404a67cd00a2333a3fd10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of arready and arvalid.  <a href="#a63c9bca94f0404a67cd00a2333a3fd10">More...</a><br /></td></tr>
<tr class="separator:a63c9bca94f0404a67cd00a2333a3fd10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a928ba573ddee36e5ca1630e30d11c1"><td class="memItemLeft" align="right" valign="top">virtual bit&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#a0a928ba573ddee36e5ca1630e30d11c1">get_arready</a> ()</td></tr>
<tr class="memdesc:a0a928ba573ddee36e5ca1630e30d11c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of arready.  <a href="#a0a928ba573ddee36e5ca1630e30d11c1">More...</a><br /></td></tr>
<tr class="separator:a0a928ba573ddee36e5ca1630e30d11c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49315c83c515d8b588ebe39b8434bf9"><td class="memItemLeft" align="right" valign="top">virtual bit&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#aa49315c83c515d8b588ebe39b8434bf9">get_rready_rvalid</a> ()</td></tr>
<tr class="memdesc:aa49315c83c515d8b588ebe39b8434bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of rready and rvalid.  <a href="#aa49315c83c515d8b588ebe39b8434bf9">More...</a><br /></td></tr>
<tr class="separator:aa49315c83c515d8b588ebe39b8434bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da0e6343f60e265dc51587206d42ba3"><td class="memItemLeft" align="right" valign="top">virtual bit&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#a5da0e6343f60e265dc51587206d42ba3">get_rvalid</a> ()</td></tr>
<tr class="memdesc:a5da0e6343f60e265dc51587206d42ba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of rvalid.  <a href="#a5da0e6343f60e265dc51587206d42ba3">More...</a><br /></td></tr>
<tr class="separator:a5da0e6343f60e265dc51587206d42ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd79e0f4ec676d038fe1d572ceb71939"><td class="memItemLeft" align="right" valign="top">virtual bit&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#acd79e0f4ec676d038fe1d572ceb71939">get_rready</a> ()</td></tr>
<tr class="memdesc:acd79e0f4ec676d038fe1d572ceb71939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of rready.  <a href="#acd79e0f4ec676d038fe1d572ceb71939">More...</a><br /></td></tr>
<tr class="separator:acd79e0f4ec676d038fe1d572ceb71939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b40988f6f7f658cf20716373ac61f0"><td class="memItemLeft" align="right" valign="top">virtual task&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#a29b40988f6f7f658cf20716373ac61f0">set_awvalid</a> (bit state)</td></tr>
<tr class="memdesc:a29b40988f6f7f658cf20716373ac61f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of awvalid.  <a href="#a29b40988f6f7f658cf20716373ac61f0">More...</a><br /></td></tr>
<tr class="separator:a29b40988f6f7f658cf20716373ac61f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7d4d682ef94552e34b4462fbb43df5"><td class="memItemLeft" align="right" valign="top">virtual task&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#a0b7d4d682ef94552e34b4462fbb43df5">set_awready</a> (bit state)</td></tr>
<tr class="memdesc:a0b7d4d682ef94552e34b4462fbb43df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of awready.  <a href="#a0b7d4d682ef94552e34b4462fbb43df5">More...</a><br /></td></tr>
<tr class="separator:a0b7d4d682ef94552e34b4462fbb43df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae2d5be2930ece9db7f5b31e895328ed"><td class="memItemLeft" align="right" valign="top">virtual task&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#aae2d5be2930ece9db7f5b31e895328ed">set_wvalid</a> (bit state)</td></tr>
<tr class="memdesc:aae2d5be2930ece9db7f5b31e895328ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of wvalid.  <a href="#aae2d5be2930ece9db7f5b31e895328ed">More...</a><br /></td></tr>
<tr class="separator:aae2d5be2930ece9db7f5b31e895328ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183ea7c33dce883d740e9b95d37c7b1a"><td class="memItemLeft" align="right" valign="top">virtual task&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#a183ea7c33dce883d740e9b95d37c7b1a">set_wready</a> (bit state)</td></tr>
<tr class="memdesc:a183ea7c33dce883d740e9b95d37c7b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of wready.  <a href="#a183ea7c33dce883d740e9b95d37c7b1a">More...</a><br /></td></tr>
<tr class="separator:a183ea7c33dce883d740e9b95d37c7b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac78126ed417bc75fa48573df7e8f1349"><td class="memItemLeft" align="right" valign="top">virtual task&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#ac78126ed417bc75fa48573df7e8f1349">set_bvalid</a> (bit state)</td></tr>
<tr class="memdesc:ac78126ed417bc75fa48573df7e8f1349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of bvalid.  <a href="#ac78126ed417bc75fa48573df7e8f1349">More...</a><br /></td></tr>
<tr class="separator:ac78126ed417bc75fa48573df7e8f1349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3de94f3b98f141c4bdcf27c553aa3cf"><td class="memItemLeft" align="right" valign="top">virtual task&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#af3de94f3b98f141c4bdcf27c553aa3cf">set_bready</a> (bit state)</td></tr>
<tr class="memdesc:af3de94f3b98f141c4bdcf27c553aa3cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of bready.  <a href="#af3de94f3b98f141c4bdcf27c553aa3cf">More...</a><br /></td></tr>
<tr class="separator:af3de94f3b98f141c4bdcf27c553aa3cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac24a02c292e31a02d5ffe11776c1456"><td class="memItemLeft" align="right" valign="top">virtual task&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#aac24a02c292e31a02d5ffe11776c1456">set_arvalid</a> (bit state)</td></tr>
<tr class="memdesc:aac24a02c292e31a02d5ffe11776c1456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of arvalid.  <a href="#aac24a02c292e31a02d5ffe11776c1456">More...</a><br /></td></tr>
<tr class="separator:aac24a02c292e31a02d5ffe11776c1456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce177e9614d440b4a2968ef2426f987"><td class="memItemLeft" align="right" valign="top">virtual task&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#a3ce177e9614d440b4a2968ef2426f987">set_rvalid</a> (bit state)</td></tr>
<tr class="memdesc:a3ce177e9614d440b4a2968ef2426f987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of rvalid.  <a href="#a3ce177e9614d440b4a2968ef2426f987">More...</a><br /></td></tr>
<tr class="separator:a3ce177e9614d440b4a2968ef2426f987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0883b7dd58da7786effb3866b5ea7433"><td class="memItemLeft" align="right" valign="top">virtual task&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#a0883b7dd58da7786effb3866b5ea7433">set_rready</a> (bit state)</td></tr>
<tr class="memdesc:a0883b7dd58da7786effb3866b5ea7433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of rready.  <a href="#a0883b7dd58da7786effb3866b5ea7433">More...</a><br /></td></tr>
<tr class="separator:a0883b7dd58da7786effb3866b5ea7433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212599a3c3966eb90b92be7156d962b6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#a212599a3c3966eb90b92be7156d962b6">enable_awready_toggle_pattern</a> (bit&lt; 31:0 &gt; pattern)</td></tr>
<tr class="memdesc:a212599a3c3966eb90b92be7156d962b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of awready toggle pattern and enable toggling.  <a href="#a212599a3c3966eb90b92be7156d962b6">More...</a><br /></td></tr>
<tr class="separator:a212599a3c3966eb90b92be7156d962b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95bb13d2cc5c21c4779f2f4ab76db2b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#ae95bb13d2cc5c21c4779f2f4ab76db2b">disable_awready_toggle_pattern</a> ()</td></tr>
<tr class="memdesc:ae95bb13d2cc5c21c4779f2f4ab76db2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable awready toggling.  <a href="#ae95bb13d2cc5c21c4779f2f4ab76db2b">More...</a><br /></td></tr>
<tr class="separator:ae95bb13d2cc5c21c4779f2f4ab76db2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ddd563ee3a778a436f9818378980927"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#a0ddd563ee3a778a436f9818378980927">enable_wready_toggle_pattern</a> (bit&lt; 31:0 &gt; pattern)</td></tr>
<tr class="memdesc:a0ddd563ee3a778a436f9818378980927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of wready toggle pattern and enable toggling.  <a href="#a0ddd563ee3a778a436f9818378980927">More...</a><br /></td></tr>
<tr class="separator:a0ddd563ee3a778a436f9818378980927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18ab40e41ea97e37e88af846270a2fb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#ac18ab40e41ea97e37e88af846270a2fb">disable_wready_toggle_pattern</a> ()</td></tr>
<tr class="memdesc:ac18ab40e41ea97e37e88af846270a2fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable wready toggling.  <a href="#ac18ab40e41ea97e37e88af846270a2fb">More...</a><br /></td></tr>
<tr class="separator:ac18ab40e41ea97e37e88af846270a2fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58321c98b31d03eabd6f8a650b42df71"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#a58321c98b31d03eabd6f8a650b42df71">enable_bready_toggle_pattern</a> (bit&lt; 31:0 &gt; pattern)</td></tr>
<tr class="memdesc:a58321c98b31d03eabd6f8a650b42df71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of bready toggle pattern and enable toggling.  <a href="#a58321c98b31d03eabd6f8a650b42df71">More...</a><br /></td></tr>
<tr class="separator:a58321c98b31d03eabd6f8a650b42df71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60864fb8651689fc67d0259dc86fa708"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#a60864fb8651689fc67d0259dc86fa708">disable_bready_toggle_pattern</a> ()</td></tr>
<tr class="memdesc:a60864fb8651689fc67d0259dc86fa708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable bready toggling.  <a href="#a60864fb8651689fc67d0259dc86fa708">More...</a><br /></td></tr>
<tr class="separator:a60864fb8651689fc67d0259dc86fa708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa10aa32bec5fbb33aa738f3b0ff537b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#afa10aa32bec5fbb33aa738f3b0ff537b">enable_arready_toggle_pattern</a> (bit&lt; 31:0 &gt; pattern)</td></tr>
<tr class="memdesc:afa10aa32bec5fbb33aa738f3b0ff537b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of arready toggle pattern and enable toggling.  <a href="#afa10aa32bec5fbb33aa738f3b0ff537b">More...</a><br /></td></tr>
<tr class="separator:afa10aa32bec5fbb33aa738f3b0ff537b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409e8cd096385a58742315b4f531cc2f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#a409e8cd096385a58742315b4f531cc2f">disable_arready_toggle_pattern</a> ()</td></tr>
<tr class="memdesc:a409e8cd096385a58742315b4f531cc2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable arready toggling.  <a href="#a409e8cd096385a58742315b4f531cc2f">More...</a><br /></td></tr>
<tr class="separator:a409e8cd096385a58742315b4f531cc2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359fdef8640289215e0632908e438da2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#a359fdef8640289215e0632908e438da2">enable_rready_toggle_pattern</a> (bit&lt; 31:0 &gt; pattern)</td></tr>
<tr class="memdesc:a359fdef8640289215e0632908e438da2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of rready toggle pattern and enable toggling.  <a href="#a359fdef8640289215e0632908e438da2">More...</a><br /></td></tr>
<tr class="separator:a359fdef8640289215e0632908e438da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd2d64a318c06c972a54171da00f452"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#a3fd2d64a318c06c972a54171da00f452">disable_rready_toggle_pattern</a> ()</td></tr>
<tr class="memdesc:a3fd2d64a318c06c972a54171da00f452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable rready toggling.  <a href="#a3fd2d64a318c06c972a54171da00f452">More...</a><br /></td></tr>
<tr class="separator:a3fd2d64a318c06c972a54171da00f452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e36789c321a0c85c24472b30e935a73"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#a7e36789c321a0c85c24472b30e935a73">write_aw</a> (<a class="el" href="axi__pkg_8sv.html#structaxi__seq__item__aw__vector__s">axi_seq_item_aw_vector_s</a> s, bit valid=0b1)</td></tr>
<tr class="memdesc:a7e36789c321a0c85c24472b30e935a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drive all the signals on the write address channel with the specified values.  <a href="#a7e36789c321a0c85c24472b30e935a73">More...</a><br /></td></tr>
<tr class="separator:a7e36789c321a0c85c24472b30e935a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac189704968e2ee86d85e6a4d9e983f0e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#ac189704968e2ee86d85e6a4d9e983f0e">write_w</a> (<a class="el" href="axi__pkg_8sv.html#structaxi__seq__item__w__vector__s">axi_seq_item_w_vector_s</a> s)</td></tr>
<tr class="memdesc:ac189704968e2ee86d85e6a4d9e983f0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drive all the signals on the write data channel with the specified values.  <a href="#ac189704968e2ee86d85e6a4d9e983f0e">More...</a><br /></td></tr>
<tr class="separator:ac189704968e2ee86d85e6a4d9e983f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c847dd3b462ab7179a3ef675854345"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#ae7c847dd3b462ab7179a3ef675854345">write_b</a> (<a class="el" href="axi__pkg_8sv.html#structaxi__seq__item__b__vector__s">axi_seq_item_b_vector_s</a> s, bit valid=0b1)</td></tr>
<tr class="memdesc:ae7c847dd3b462ab7179a3ef675854345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drive all the signals on the write response channel with the specified values.  <a href="#ae7c847dd3b462ab7179a3ef675854345">More...</a><br /></td></tr>
<tr class="separator:ae7c847dd3b462ab7179a3ef675854345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa28079f55a85b0840fda5096cb681b78"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#aa28079f55a85b0840fda5096cb681b78">read_aw</a> (output <a class="el" href="axi__pkg_8sv.html#structaxi__seq__item__aw__vector__s">axi_seq_item_aw_vector_s</a> s)</td></tr>
<tr class="memdesc:aa28079f55a85b0840fda5096cb681b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the values on the write address channel.  <a href="#aa28079f55a85b0840fda5096cb681b78">More...</a><br /></td></tr>
<tr class="separator:aa28079f55a85b0840fda5096cb681b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b57e93cd1e99ab4dd4203e90bca8e7b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#a3b57e93cd1e99ab4dd4203e90bca8e7b">read_w</a> (output <a class="el" href="axi__pkg_8sv.html#structaxi__seq__item__w__vector__s">axi_seq_item_w_vector_s</a> s)</td></tr>
<tr class="memdesc:a3b57e93cd1e99ab4dd4203e90bca8e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the values on the write data channel.  <a href="#a3b57e93cd1e99ab4dd4203e90bca8e7b">More...</a><br /></td></tr>
<tr class="separator:a3b57e93cd1e99ab4dd4203e90bca8e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49bde9c259f66ed1ba98144d672efc2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#ac49bde9c259f66ed1ba98144d672efc2">read_b</a> (output <a class="el" href="axi__pkg_8sv.html#structaxi__seq__item__b__vector__s">axi_seq_item_b_vector_s</a> s)</td></tr>
<tr class="memdesc:ac49bde9c259f66ed1ba98144d672efc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the values on the write response channel.  <a href="#ac49bde9c259f66ed1ba98144d672efc2">More...</a><br /></td></tr>
<tr class="separator:ac49bde9c259f66ed1ba98144d672efc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f862f7fca7efb90751aa39479d9d90"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#a75f862f7fca7efb90751aa39479d9d90">write_ar</a> (<a class="el" href="axi__pkg_8sv.html#structaxi__seq__item__ar__vector__s">axi_seq_item_ar_vector_s</a> s, bit valid=0b1)</td></tr>
<tr class="memdesc:a75f862f7fca7efb90751aa39479d9d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drive all the signals on the read address channel with the specified values.  <a href="#a75f862f7fca7efb90751aa39479d9d90">More...</a><br /></td></tr>
<tr class="separator:a75f862f7fca7efb90751aa39479d9d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5d4c671f5f12e9f262ed27053941d9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#a4f5d4c671f5f12e9f262ed27053941d9">write_r</a> (<a class="el" href="axi__pkg_8sv.html#structaxi__seq__item__r__vector__s">axi_seq_item_r_vector_s</a> s)</td></tr>
<tr class="memdesc:a4f5d4c671f5f12e9f262ed27053941d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drive all the signals on the read data channel with the specified values.  <a href="#a4f5d4c671f5f12e9f262ed27053941d9">More...</a><br /></td></tr>
<tr class="separator:a4f5d4c671f5f12e9f262ed27053941d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4008213a66c4b59ded6f86dc21d9c269"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#a4008213a66c4b59ded6f86dc21d9c269">read_ar</a> (output <a class="el" href="axi__pkg_8sv.html#structaxi__seq__item__ar__vector__s">axi_seq_item_ar_vector_s</a> s)</td></tr>
<tr class="memdesc:a4008213a66c4b59ded6f86dc21d9c269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the values on the read address channel.  <a href="#a4008213a66c4b59ded6f86dc21d9c269">More...</a><br /></td></tr>
<tr class="separator:a4008213a66c4b59ded6f86dc21d9c269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643df09adab92fac2aab26171c25c3d4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaxi__if__abstract.html#a643df09adab92fac2aab26171c25c3d4">read_r</a> (output <a class="el" href="axi__pkg_8sv.html#structaxi__seq__item__r__vector__s">axi_seq_item_r_vector_s</a> s)</td></tr>
<tr class="memdesc:a643df09adab92fac2aab26171c25c3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the values on the read data channel.  <a href="#a643df09adab92fac2aab26171c25c3d4">More...</a><br /></td></tr>
<tr class="separator:a643df09adab92fac2aab26171c25c3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>abstract base class for polymorphic interface class (axi_if_concrete) for AXI UVM environment </p>
<p>This class is extended by a class called axi_if_concrete that is nested inside axi_if. The class methods have access to the interface's internals so can drive signals, read signals, etc. The class also registers with the uvm_config_db and does a set_type_override so we get the concrete class instead of the abstract class. This lets us use a class and not have to parameterize an interface and all the UVC stuff that talks to it. All the functions and tasks are for the testbench to talk to the DUT as efficiently as possible but in an understandable way. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="axi__if_8sv.html">axi_if.sv</a> </dd></dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00029">29</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a409e8cd096385a58742315b4f531cc2f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void axi_if_abstract::disable_arready_toggle_pattern </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable arready toggling. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000010">Todo:</a></b></dt><dd>: what happens when disabled..</dd></dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00496">496</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="ae95bb13d2cc5c21c4779f2f4ab76db2b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void axi_if_abstract::disable_awready_toggle_pattern </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable awready toggling. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>: what happens when disabled..</dd></dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00442">442</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="a60864fb8651689fc67d0259dc86fa708"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void axi_if_abstract::disable_bready_toggle_pattern </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable bready toggling. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd>: what happens when disabled..</dd></dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00478">478</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="a3fd2d64a318c06c972a54171da00f452"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void axi_if_abstract::disable_rready_toggle_pattern </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable rready toggling. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000011">Todo:</a></b></dt><dd>: what happens when disabled..</dd></dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00514">514</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="ac18ab40e41ea97e37e88af846270a2fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void axi_if_abstract::disable_wready_toggle_pattern </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable wready toggling. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>: what happens when disabled..</dd></dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00460">460</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="afa10aa32bec5fbb33aa738f3b0ff537b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void axi_if_abstract::enable_arready_toggle_pattern </td>
          <td>(</td>
          <td class="paramtype">bit&lt; 31:0 &gt;&#160;</td>
          <td class="paramname"><em>pattern</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of arready toggle pattern and enable toggling. </p>
<p>arready can be toggled pseudo randonly with a repeating 32-bit pattern </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- barrel register value to use to toggle arready </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00487">487</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="a212599a3c3966eb90b92be7156d962b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void axi_if_abstract::enable_awready_toggle_pattern </td>
          <td>(</td>
          <td class="paramtype">bit&lt; 31:0 &gt;&#160;</td>
          <td class="paramname"><em>pattern</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of awready toggle pattern and enable toggling. </p>
<p>awready can be toggled pseudo randonly with a repeating 32-bit pattern </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- barrel register value to use to toggle awready </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00433">433</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="a58321c98b31d03eabd6f8a650b42df71"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void axi_if_abstract::enable_bready_toggle_pattern </td>
          <td>(</td>
          <td class="paramtype">bit&lt; 31:0 &gt;&#160;</td>
          <td class="paramname"><em>pattern</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of bready toggle pattern and enable toggling. </p>
<p>bready can be toggled pseudo randonly with a repeating 32-bit pattern </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- barrel register value to use to toggle bready </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00469">469</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="a359fdef8640289215e0632908e438da2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void axi_if_abstract::enable_rready_toggle_pattern </td>
          <td>(</td>
          <td class="paramtype">bit&lt; 31:0 &gt;&#160;</td>
          <td class="paramname"><em>pattern</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of rready toggle pattern and enable toggling. </p>
<p>rready can be toggled pseudo randonly with a repeating 32-bit pattern </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- barrel register value to use to toggle rready </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00505">505</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="a0ddd563ee3a778a436f9818378980927"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void axi_if_abstract::enable_wready_toggle_pattern </td>
          <td>(</td>
          <td class="paramtype">bit&lt; 31:0 &gt;&#160;</td>
          <td class="paramname"><em>pattern</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of wready toggle pattern and enable toggling. </p>
<p>wready can be toggled pseudo randonly with a repeating 32-bit pattern </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>- barrel register value to use to toggle wready </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00451">451</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="a0a928ba573ddee36e5ca1630e30d11c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bit axi_if_abstract::get_arready </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value of arready. </p>
<p>(Is the slave currently ready for a read address?) </p><dl class="section return"><dt>Returns</dt><dd>value of arready </dd></dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00310">310</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="a63c9bca94f0404a67cd00a2333a3fd10"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bit axi_if_abstract::get_arready_arvalid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value of arready and arvalid. </p>
<p>(Is the read address channel currently being acknowledged by the slave?) One function instead of two seperate to save a call from testbench land to RTL land (this only really matters in emulator and even then not that much.) </p><dl class="section return"><dt>Returns</dt><dd>true if both arvalid and arready are asserted else false </dd></dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00300">300</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="a9ffe576057c4ab3cb114da13d10626f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bit axi_if_abstract::get_awready </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value of awready. </p>
<p>(Is the slave currently ready for a write address?) </p><dl class="section return"><dt>Returns</dt><dd>value of awready </dd></dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00224">224</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="abbf98bd165754605b7878b05f63fe8b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bit axi_if_abstract::get_awready_awvalid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value of awready and awvalid. </p>
<p>(Is the write address channel currently being acknowledged by the slave?) One function instead of two seperate to save a call from testbench land to RTL land (this only really matters in emulator and even then not that much.) </p><dl class="section return"><dt>Returns</dt><dd>true if both awvalid and awready are asserted else false </dd></dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00213">213</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="ad1a26bec3816fad1bb2155873214e9fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bit axi_if_abstract::get_bready </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value of bready. </p>
<p>(Is the master currently ready for a write response?) </p><dl class="section return"><dt>Returns</dt><dd>value of bready </dd></dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00288">288</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="afc4f687586493cda59b997ecb9b06755"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bit axi_if_abstract::get_bready_bvalid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value of bready and bvalid. </p>
<p>(Is the write response channel currently being acknowledged by the slave?) One function instead of two seperate to save a call from testbench land to RTL land (this only really matters in emulator and even then not that much.) </p><dl class="section return"><dt>Returns</dt><dd>true if both bvalid and bready are asserted else false </dd></dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00268">268</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="a6e480323f9947438602bf6b5029783e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bit axi_if_abstract::get_bvalid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value of bvalid. </p>
<p>(Is the write response currently valid?) </p><dl class="section return"><dt>Returns</dt><dd>value of bvalid </dd></dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00278">278</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="a834de2d058eec05c4c890435fae83a5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int axi_if_abstract::get_data_bus_width </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns data bus width </p>
<p>This function allows the driver to retrieve the data bus width from the interface. </p>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00109">109</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

<p>Referenced by <a class="el" href="axi__monitor_8svh_source.html#l00308">axi_monitor::read_address()</a>, and <a class="el" href="axi__monitor_8svh_source.html#l00161">axi_monitor::write_data()</a>.</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classaxi__if__abstract_a834de2d058eec05c4c890435fae83a5b_icgraph.png" border="0" usemap="#classaxi__if__abstract_a834de2d058eec05c4c890435fae83a5b_icgraph" alt=""/></div>
<map name="classaxi__if__abstract_a834de2d058eec05c4c890435fae83a5b_icgraph" id="classaxi__if__abstract_a834de2d058eec05c4c890435fae83a5b_icgraph">
<area shape="rect" id="node2" href="classaxi__monitor.html#a1894a2a0b2a491fc4cfc047fe5bc62e9" title="monitors Read Address channel " alt="" coords="187,5,361,32"/>
<area shape="rect" id="node4" href="classaxi__monitor.html#a533d709a6e06148b22425eb52277983b" title="monitors Write Data channel " alt="" coords="195,56,353,83"/>
<area shape="rect" id="node3" href="classaxi__monitor.html#a34a7e7fb040dbba2301f67bf6e40fe91" title="Starts the monitoring threads. " alt="" coords="409,31,567,57"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="acd79e0f4ec676d038fe1d572ceb71939"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bit axi_if_abstract::get_rready </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value of rready. </p>
<p>(Is the master currently ready for a read data?) </p><dl class="section return"><dt>Returns</dt><dd>value of rready </dd></dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00342">342</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="aa49315c83c515d8b588ebe39b8434bf9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bit axi_if_abstract::get_rready_rvalid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value of rready and rvalid. </p>
<p>(Is the read data channel currently being acknowledged by the slave?) One function instead of two seperate to save a call from testbench land to RTL land (this only really matters in emulator and even then not that much.) </p><dl class="section return"><dt>Returns</dt><dd>true if both rvalid and rready are asserted else false </dd></dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00322">322</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="a5da0e6343f60e265dc51587206d42ba3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bit axi_if_abstract::get_rvalid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value of rvalid. </p>
<p>(Is the read data currently valid?) </p><dl class="section return"><dt>Returns</dt><dd>value of awready </dd></dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00332">332</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="ab14f30e2f16ecda87111231fa0a1a332"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bit axi_if_abstract::get_wready </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value of wready. </p>
<p>(Is the slave currently ready for a write data?) </p><dl class="section return"><dt>Returns</dt><dd>value of wready </dd></dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00256">256</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="aa90f9b3a4524fa9a6fd7085292e2e109"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bit axi_if_abstract::get_wready_wvalid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value of wready and wvalid. </p>
<p>(Is the write data channel currently being acknowledged by the slave?) One function instead of two seperate to save a call from testbench land to RTL land (this only really matters in emulator and even then not that much.) </p><dl class="section return"><dt>Returns</dt><dd>true if both wvalid and wready are asserted else false </dd></dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00236">236</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="a7b5812097a1ebe2ea45d79b9453fccaa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bit axi_if_abstract::get_wvalid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value of wvalid. </p>
<p>(Is the write data currently valid?) </p><dl class="section return"><dt>Returns</dt><dd>value of awready </dd></dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00246">246</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="a4008213a66c4b59ded6f86dc21d9c269"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void axi_if_abstract::read_ar </td>
          <td>(</td>
          <td class="paramtype">output <a class="el" href="axi__pkg_8sv.html#structaxi__seq__item__ar__vector__s">axi_seq_item_ar_vector_s</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the values on the read address channel. </p>
<p>s is a packed struct to ease usage in an emulator environment (like Veloce). </p><dl class="section return"><dt>Returns</dt><dd>packed struct of read address channel signal values. </dd></dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00590">590</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="aa28079f55a85b0840fda5096cb681b78"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void axi_if_abstract::read_aw </td>
          <td>(</td>
          <td class="paramtype">output <a class="el" href="axi__pkg_8sv.html#structaxi__seq__item__aw__vector__s">axi_seq_item_aw_vector_s</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the values on the write address channel. </p>
<p>s is a packed struct to ease usage in an emulator environment (like Veloce). </p><dl class="section return"><dt>Returns</dt><dd>packed struct of write address channel signal values. </dd></dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00553">553</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="ac49bde9c259f66ed1ba98144d672efc2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void axi_if_abstract::read_b </td>
          <td>(</td>
          <td class="paramtype">output <a class="el" href="axi__pkg_8sv.html#structaxi__seq__item__b__vector__s">axi_seq_item_b_vector_s</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the values on the write response channel. </p>
<p>s is a packed struct to ease usage in an emulator environment (like Veloce). </p><dl class="section return"><dt>Returns</dt><dd>packed struct of write response channel signal values. </dd></dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00571">571</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="a643df09adab92fac2aab26171c25c3d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void axi_if_abstract::read_r </td>
          <td>(</td>
          <td class="paramtype">output <a class="el" href="axi__pkg_8sv.html#structaxi__seq__item__r__vector__s">axi_seq_item_r_vector_s</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the values on the read data channel. </p>
<p>s is a packed struct to ease usage in an emulator environment (like Veloce). </p><dl class="section return"><dt>Returns</dt><dd>packed struct of read data channel signal values. </dd></dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00608">608</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="a3b57e93cd1e99ab4dd4203e90bca8e7b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void axi_if_abstract::read_w </td>
          <td>(</td>
          <td class="paramtype">output <a class="el" href="axi__pkg_8sv.html#structaxi__seq__item__w__vector__s">axi_seq_item_w_vector_s</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the values on the write data channel. </p>
<p>s is a packed struct to ease usage in an emulator environment (like Veloce). </p><dl class="section return"><dt>Returns</dt><dd>packed struct of write data channel signal values. </dd></dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00562">562</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="aac24a02c292e31a02d5ffe11776c1456"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">task axi_if_abstract::set_arvalid </td>
          <td>(</td>
          <td class="paramtype">bit&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of arvalid. </p>
<p>(true=read address is valid; false=read address is not valid) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>- value to drive arvalid </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00406">406</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="a0b7d4d682ef94552e34b4462fbb43df5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">task axi_if_abstract::set_awready </td>
          <td>(</td>
          <td class="paramtype">bit&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of awready. </p>
<p>(true=slave is ready for write address; false=slave is not ready.) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>- value to drive awready </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00361">361</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="a29b40988f6f7f658cf20716373ac61f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">task axi_if_abstract::set_awvalid </td>
          <td>(</td>
          <td class="paramtype">bit&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of awvalid. </p>
<p>(true=write address is valid; false=write address is not valid) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>- value to drive awvalid </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00352">352</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="af3de94f3b98f141c4bdcf27c553aa3cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">task axi_if_abstract::set_bready </td>
          <td>(</td>
          <td class="paramtype">bit&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of bready. </p>
<p>(true=master is ready for write response; false=master is not ready.) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>- value to drive bready </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00397">397</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="ac78126ed417bc75fa48573df7e8f1349"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">task axi_if_abstract::set_bvalid </td>
          <td>(</td>
          <td class="paramtype">bit&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of bvalid. </p>
<p>(true=write response is valid; false=write response is not valid) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>- value to drive bvalid </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00388">388</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="a0883b7dd58da7786effb3866b5ea7433"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">task axi_if_abstract::set_rready </td>
          <td>(</td>
          <td class="paramtype">bit&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of rready. </p>
<p>(true=master is ready for read data; false=master is not ready.) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>- value to drive rready </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00424">424</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="a3ce177e9614d440b4a2968ef2426f987"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">task axi_if_abstract::set_rvalid </td>
          <td>(</td>
          <td class="paramtype">bit&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of rvalid. </p>
<p>(true=read data is valid; false=read data is not valid) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>- value to drive rvalid </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00415">415</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="a183ea7c33dce883d740e9b95d37c7b1a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">task axi_if_abstract::set_wready </td>
          <td>(</td>
          <td class="paramtype">bit&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of wready. </p>
<p>(true=slave is ready for write data; false=slave is not ready.) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>- value to drive wready </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00379">379</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="aae2d5be2930ece9db7f5b31e895328ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">task axi_if_abstract::set_wvalid </td>
          <td>(</td>
          <td class="paramtype">bit&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of wvalid. </p>
<p>(true=write data is valid; false=write data is not valid) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>- value to drive wvalid </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00370">370</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="a9ec99974902d3dee6694b6731631e326"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">axi_if_abstract::uvm_object_utils </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaxi__if__abstract.html">axi_if_abstract</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">new</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae136ae0143b1a3fccc030fbdb9dd32fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">task axi_if_abstract::wait_for_awready_awvalid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for both awready awvalid to assert. </p>
<p>Used to know when the write address has been received and acknowledged by slave </p>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00133">133</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="ac91fb21011e5b40e3d25aeea49284220"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">task axi_if_abstract::wait_for_awvalid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for awvalid to assert. </p>
<p>Used to wait for when a valid write address is on the channel. </p>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00141">141</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="a82d26646215b46420b0cfd2ab10127d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">task axi_if_abstract::wait_for_bvalid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for bvalid to assert. </p>
<p>Used to wait for when a valid write response is on the channel. </p>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00157">157</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="a79c572b96776c9da41b06e86331ed0e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">task axi_if_abstract::wait_for_clks </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cnt</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>used for waiting </p>
<p>The testbench side is entirely event driven (or is meant to be). This function is called to wait for time </p>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00119">119</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="ad3c1b5d16686699c5916f43aa20ae278"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">task axi_if_abstract::wait_for_not_in_reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for reset to deassert. </p>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00125">125</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="ac122b014826138edcbb74b601b625364"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">task axi_if_abstract::wait_for_read_address </td>
          <td>(</td>
          <td class="paramtype">output <a class="el" href="axi__pkg_8sv.html#structaxi__seq__item__ar__vector__s">axi_seq_item_ar_vector_s</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for a valid read address to be acknowledged and return it. </p>
<p>Used to wait for, and return, a valid read address. </p><dl class="section return"><dt>Returns</dt><dd>values on the read address channel. </dd></dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00193">193</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

<p>Referenced by <a class="el" href="axi__monitor_8svh_source.html#l00308">axi_monitor::read_address()</a>.</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classaxi__if__abstract_ac122b014826138edcbb74b601b625364_icgraph.png" border="0" usemap="#classaxi__if__abstract_ac122b014826138edcbb74b601b625364_icgraph" alt=""/></div>
<map name="classaxi__if__abstract_ac122b014826138edcbb74b601b625364_icgraph" id="classaxi__if__abstract_ac122b014826138edcbb74b601b625364_icgraph">
<area shape="rect" id="node2" href="classaxi__monitor.html#a1894a2a0b2a491fc4cfc047fe5bc62e9" title="monitors Read Address channel " alt="" coords="192,13,367,39"/>
<area shape="rect" id="node3" href="classaxi__monitor.html#a34a7e7fb040dbba2301f67bf6e40fe91" title="Starts the monitoring threads. " alt="" coords="415,13,572,39"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ad72883433768852cedc9acbf5263e071"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">task axi_if_abstract::wait_for_read_data </td>
          <td>(</td>
          <td class="paramtype">output <a class="el" href="axi__pkg_8sv.html#structaxi__seq__item__r__vector__s">axi_seq_item_r_vector_s</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for a valid read data to be acknowledged and return it. </p>
<p>Used to wait for, and return, a valid read data. </p><dl class="section return"><dt>Returns</dt><dd>values on the read data channel. </dd></dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00202">202</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

<p>Referenced by <a class="el" href="axi__monitor_8svh_source.html#l00465">axi_monitor::read_data()</a>.</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classaxi__if__abstract_ad72883433768852cedc9acbf5263e071_icgraph.png" border="0" usemap="#classaxi__if__abstract_ad72883433768852cedc9acbf5263e071_icgraph" alt=""/></div>
<map name="classaxi__if__abstract_ad72883433768852cedc9acbf5263e071_icgraph" id="classaxi__if__abstract_ad72883433768852cedc9acbf5263e071_icgraph">
<area shape="rect" id="node2" href="classaxi__monitor.html#ae9d073687e001b3bde7cc83e11c76a96" title="monitors Read Data channel and sends out TLM pkt Loop Wait for activity on the Read Data Channel..." alt="" coords="192,13,347,39"/>
<area shape="rect" id="node3" href="classaxi__monitor.html#a34a7e7fb040dbba2301f67bf6e40fe91" title="Starts the monitoring threads. " alt="" coords="617,13,775,39"/>
<area shape="rect" id="node4" href="classaxi__monitor.html#a1894a2a0b2a491fc4cfc047fe5bc62e9" title="monitors Read Address channel " alt="" coords="395,38,569,65"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="aee8a696dbe605ca57a204f691e3b99db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">task axi_if_abstract::wait_for_wready </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for awready to assert. </p>
<p>Used to wait for when the slave is ready for write data </p>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00149">149</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="a9e019c384309938d98fb93eb9d19ee35"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">task axi_if_abstract::wait_for_write_address </td>
          <td>(</td>
          <td class="paramtype">output <a class="el" href="axi__pkg_8sv.html#structaxi__seq__item__aw__vector__s">axi_seq_item_aw_vector_s</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for a valid write address to be acknowledged and return it. </p>
<p>Used to wait for, and return, a valid write address. </p><dl class="section return"><dt>Returns</dt><dd>values on the write address channel. </dd></dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00166">166</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

<p>Referenced by <a class="el" href="axi__monitor_8svh_source.html#l00108">axi_monitor::write_address()</a>.</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classaxi__if__abstract_a9e019c384309938d98fb93eb9d19ee35_icgraph.png" border="0" usemap="#classaxi__if__abstract_a9e019c384309938d98fb93eb9d19ee35_icgraph" alt=""/></div>
<map name="classaxi__if__abstract_a9e019c384309938d98fb93eb9d19ee35_icgraph" id="classaxi__if__abstract_a9e019c384309938d98fb93eb9d19ee35_icgraph">
<area shape="rect" id="node2" href="classaxi__monitor.html#a6b7dc286ef67470782ca0d74f60dc692" title="monitors Write Address channel " alt="" coords="192,5,317,47"/>
<area shape="rect" id="node3" href="classaxi__monitor.html#a34a7e7fb040dbba2301f67bf6e40fe91" title="Starts the monitoring threads. " alt="" coords="365,13,523,39"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ae1a2ca6a8c9c35f84db03942796fc092"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">task axi_if_abstract::wait_for_write_data </td>
          <td>(</td>
          <td class="paramtype">output <a class="el" href="axi__pkg_8sv.html#structaxi__seq__item__w__vector__s">axi_seq_item_w_vector_s</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for a valid write data to be acknowledged and return it. </p>
<p>Used to wait for, and return, a valid write data beat. </p><dl class="section return"><dt>Returns</dt><dd>values on the write data channel. </dd></dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00175">175</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

<p>Referenced by <a class="el" href="axi__monitor_8svh_source.html#l00161">axi_monitor::write_data()</a>.</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classaxi__if__abstract_ae1a2ca6a8c9c35f84db03942796fc092_icgraph.png" border="0" usemap="#classaxi__if__abstract_ae1a2ca6a8c9c35f84db03942796fc092_icgraph" alt=""/></div>
<map name="classaxi__if__abstract_ae1a2ca6a8c9c35f84db03942796fc092_icgraph" id="classaxi__if__abstract_ae1a2ca6a8c9c35f84db03942796fc092_icgraph">
<area shape="rect" id="node2" href="classaxi__monitor.html#a533d709a6e06148b22425eb52277983b" title="monitors Write Data channel " alt="" coords="192,13,349,39"/>
<area shape="rect" id="node3" href="classaxi__monitor.html#a34a7e7fb040dbba2301f67bf6e40fe91" title="Starts the monitoring threads. " alt="" coords="397,13,555,39"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a5030adaa9d120c151c041912c25bc538"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">task axi_if_abstract::wait_for_write_response </td>
          <td>(</td>
          <td class="paramtype">output <a class="el" href="axi__pkg_8sv.html#structaxi__seq__item__b__vector__s">axi_seq_item_b_vector_s</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for a valid write response to be acknowledged and return it. </p>
<p>Used to wait for, and return, a valid write response. </p><dl class="section return"><dt>Returns</dt><dd>values on the write response channel. </dd></dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00184">184</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

<p>Referenced by <a class="el" href="axi__monitor_8svh_source.html#l00275">axi_monitor::write_response()</a>.</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classaxi__if__abstract_a5030adaa9d120c151c041912c25bc538_icgraph.png" border="0" usemap="#classaxi__if__abstract_a5030adaa9d120c151c041912c25bc538_icgraph" alt=""/></div>
<map name="classaxi__if__abstract_a5030adaa9d120c151c041912c25bc538_icgraph" id="classaxi__if__abstract_a5030adaa9d120c151c041912c25bc538_icgraph">
<area shape="rect" id="node2" href="classaxi__monitor.html#a999c77ab0723510d713bc1d89b1f5c92" title="monitors Write Response channel and sends out TLM pkt Loop Wait for activity on the Write Response Ch..." alt="" coords="192,5,317,47"/>
<area shape="rect" id="node3" href="classaxi__monitor.html#a34a7e7fb040dbba2301f67bf6e40fe91" title="Starts the monitoring threads. " alt="" coords="365,13,523,39"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a75f862f7fca7efb90751aa39479d9d90"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void axi_if_abstract::write_ar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="axi__pkg_8sv.html#structaxi__seq__item__ar__vector__s">axi_seq_item_ar_vector_s</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bit&#160;</td>
          <td class="paramname"><em>valid</em> = <code>0b1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drive all the signals on the read address channel with the specified values. </p>
<p>s is a packed struct to ease usage in an emulator environment(like Veloce) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>- packed struct containing all read address channel signal values (except arvalid) </td></tr>
    <tr><td class="paramname">valid</td><td>- value to drive on arvalid </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00581">581</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="a7e36789c321a0c85c24472b30e935a73"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void axi_if_abstract::write_aw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="axi__pkg_8sv.html#structaxi__seq__item__aw__vector__s">axi_seq_item_aw_vector_s</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bit&#160;</td>
          <td class="paramname"><em>valid</em> = <code>0b1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drive all the signals on the write address channel with the specified values. </p>
<p>s is a packed struct to ease usage in an emulator environment(like Veloce) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>- packed struct containing all write address channel signal values (except awvalid) </td></tr>
    <tr><td class="paramname">valid</td><td>- value to drive on awvalid </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00524">524</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="ae7c847dd3b462ab7179a3ef675854345"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void axi_if_abstract::write_b </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="axi__pkg_8sv.html#structaxi__seq__item__b__vector__s">axi_seq_item_b_vector_s</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bit&#160;</td>
          <td class="paramname"><em>valid</em> = <code>0b1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drive all the signals on the write response channel with the specified values. </p>
<p>s is a packed struct to ease usage in an emulator environment(like Veloce) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>- packed struct containing all write response channel signal values (except bvalid) </td></tr>
    <tr><td class="paramname">valid</td><td>- value to drive on bvalid </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00544">544</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="a4f5d4c671f5f12e9f262ed27053941d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void axi_if_abstract::write_r </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="axi__pkg_8sv.html#structaxi__seq__item__r__vector__s">axi_seq_item_r_vector_s</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drive all the signals on the read data channel with the specified values. </p>
<p>s is a packed struct to ease usage in an emulator environment(like Veloce) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>- packed struct containing all read data channel signal values </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00599">599</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<a class="anchor" id="ac189704968e2ee86d85e6a4d9e983f0e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void axi_if_abstract::write_w </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="axi__pkg_8sv.html#structaxi__seq__item__w__vector__s">axi_seq_item_w_vector_s</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drive all the signals on the write data channel with the specified values. </p>
<p>s is a packed struct to ease usage in an emulator environment(like Veloce) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>- packed struct containing all write data channel signal values </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000012">Todo:</a></b></dt><dd>: is this parameter still used anywhere? </dd></dl>

<p>Definition at line <a class="el" href="axi__if__abstract_8svh_source.html#l00534">534</a> of file <a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>tb/<a class="el" href="axi__if__abstract_8svh_source.html">axi_if_abstract.svh</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
